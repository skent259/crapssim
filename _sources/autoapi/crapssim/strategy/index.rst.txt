crapssim.strategy
=================

.. py:module:: crapssim.strategy

.. autoapi-nested-parse::

   Strategies to be assigned to players on the Craps table. The strategy determines what bets the
   player should make, remove, or change. Strategies are applied for the player to change the bets
   after the previous bets and table have been updated.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/crapssim/strategy/examples/index
   /autoapi/crapssim/strategy/odds/index
   /autoapi/crapssim/strategy/single_bet/index
   /autoapi/crapssim/strategy/tools/index


Classes
-------

.. autoapisummary::

   crapssim.strategy.ComeOddsMultiplier
   crapssim.strategy.DontComeOddsMultiplier
   crapssim.strategy.DontPassOddsMultiplier
   crapssim.strategy.OddsAmount
   crapssim.strategy.OddsMultiplier
   crapssim.strategy.PassLineOddsMultiplier
   crapssim.strategy.BetDontPass
   crapssim.strategy.BetPassLine
   crapssim.strategy.BetPlace
   crapssim.strategy.AddIfNewShooter
   crapssim.strategy.AddIfNotBet
   crapssim.strategy.AddIfPointOff
   crapssim.strategy.AddIfPointOn
   crapssim.strategy.AddIfTrue
   crapssim.strategy.AggregateStrategy
   crapssim.strategy.CountStrategy
   crapssim.strategy.RemoveIfPointOff
   crapssim.strategy.RemoveIfTrue
   crapssim.strategy.Strategy


Package Contents
----------------

.. py:class:: ComeOddsMultiplier(odds_multiplier: MultiplierDict | SupportsFloat | None = None, always_working: bool = False)

   Bases: :py:obj:`_BaseOddsMultiplier`


   Adds Come Odds on specified odds multiplier(s)


   .. py:attribute:: bet_type


   .. py:attribute:: default_multiplier


.. py:class:: DontComeOddsMultiplier(odds_multiplier: MultiplierDict | SupportsFloat | None = None, always_working: bool = False)

   Bases: :py:obj:`_BaseOddsMultiplier`


   Adds DontCome Odds on specified odds multiplier(s)


   .. py:attribute:: bet_type


   .. py:attribute:: default_multiplier
      :value: 6.0



.. py:class:: DontPassOddsMultiplier(odds_multiplier: MultiplierDict | SupportsFloat | None = None, always_working: bool = False)

   Bases: :py:obj:`_BaseOddsMultiplier`


   Adds DontPass Odds on specified odds multiplier(s)


   .. py:attribute:: bet_type


   .. py:attribute:: default_multiplier
      :value: 6.0



.. py:class:: OddsAmount(base_type: type[crapssim.bet.PassLine | crapssim.bet.DontPass | crapssim.bet.Come | crapssim.bet.DontCome | crapssim.bet.Put], odds_amounts: SupportsFloat | MultiplierDict, always_working: bool = False)

   Bases: :py:obj:`crapssim.strategy.tools.Strategy`


   Adds Odds for the bet type and specified numbers

   :param base_type: The bet that odds will be added to.
   :param odds_amounts: A dictionary of point numbers and the amount to bet
                        on each number.
   :param always_working: Whether the odds are working when the point is off.
   :type always_working: bool


   .. py:attribute:: base_type

      The bet that odds will be added to.


   .. py:attribute:: odds_amounts


   .. py:attribute:: always_working
      :value: False



   .. py:method:: completed(player: crapssim.strategy.tools.Player) -> bool

      Return True if there are no bets of base_type on the table.

      :param player: The player whose bets to check for.

      :rtype: True if there are no base type bets on the table, otherwise False.



   .. py:method:: update_bets(player: crapssim.strategy.tools.Player) -> None


   .. py:method:: _get_always_working_repr() -> str

      Since the default is false, only need to print when True



   .. py:method:: __repr__()


.. py:class:: OddsMultiplier(base_type: type[crapssim.bet.PassLine | crapssim.bet.DontPass | crapssim.bet.Come | crapssim.bet.DontCome | crapssim.bet.Put], odds_multiplier: MultiplierDict | SupportsFloat, always_working: bool = False)

   Bases: :py:obj:`crapssim.strategy.tools.Strategy`


   Adds Odds for the bet type and desired odds multiplier

   :param base_type: The bet that odds will be added to.
   :param odds_multiplier: If odds_multiplier is a float, adds multiplier * base_bets amount to the odds.
                           If the odds multiplier is a dictionary of floats, looks at the dictionary to
                           determine what odds multiplier to use depending on the given point.
   :param always_working: Whether the odds are working when the point is off.
   :type always_working: bool


   .. py:attribute:: base_type


   .. py:attribute:: always_working
      :value: False



   .. py:attribute:: odds_multiplier


   .. py:method:: get_point_number(bet: crapssim.bet.Bet, table: crapssim.strategy.tools.Table)
      :staticmethod:



   .. py:method:: update_bets(player: crapssim.strategy.tools.Player) -> None

      Add an Odds bet to the given base_types in the amount determined by the odds_multiplier.

      :param player: The player to add the odds bet to.



   .. py:method:: completed(player: crapssim.strategy.tools.Player) -> bool

      Return True if there are no bets of base_type on the table.

      :param player: The player whose bets to check for.

      :rtype: True if there are no base type bets on the table, otherwise False.



   .. py:method:: _get_always_working_repr() -> str

      Since the default is false, only need to print when True



   .. py:method:: __repr__() -> str


.. py:class:: PassLineOddsMultiplier(odds_multiplier: MultiplierDict | SupportsFloat | None = None, always_working: bool = False)

   Bases: :py:obj:`_BaseOddsMultiplier`


   Adds PassLine Odds on specified odds multiplier(s)


   .. py:attribute:: bet_type


   .. py:attribute:: default_multiplier


.. py:class:: BetDontPass(bet_amount: SupportsFloat, mode=StrategyMode.ADD_IF_POINT_OFF)

   Bases: :py:obj:`_BaseSingleBet`


   Base helper for wrapping a single :class:`Bet` in a strategy.


.. py:class:: BetPassLine(bet_amount: SupportsFloat, mode=StrategyMode.ADD_IF_POINT_OFF)

   Bases: :py:obj:`_BaseSingleBet`


   Base helper for wrapping a single :class:`Bet` in a strategy.


.. py:class:: BetPlace(place_bet_amounts: dict[int, float], mode: StrategyMode = StrategyMode.BET_IF_POINT_ON, skip_point: bool = True, skip_come: bool = False)

   Bases: :py:obj:`crapssim.strategy.tools.Strategy`


   Strategy that makes multiple Place bets of given amounts. It can also skip making the bet
   if the point is the same as the given bet number.


   .. py:attribute:: place_bet_amounts


   .. py:attribute:: mode


   .. py:attribute:: skip_point
      :value: True



   .. py:attribute:: skip_come
      :value: False



   .. py:method:: completed(player: crapssim.strategy.tools.Player) -> bool

      The strategy is completed if the player can no longer make any of the place bets in the
      place_bet_amounts dictionary and there are no Place bets on the table.

      :param player: The player to check the bankroll for

      :returns: * *True if there are no Place bets on the table and the player can't make any more Place bets*
                * *because their bankroll is too low.*



   .. py:method:: update_bets(player: crapssim.strategy.tools.Player) -> None

      Add the place bets on the numbers and amounts defined by place_bet_amounts.

      :param player: The player to add the place bets to.



   .. py:method:: remove_point_bet(player: crapssim.strategy.tools.Player) -> None
      :staticmethod:


      If skip_point is true and the player has a place bet for the table point number,
      remove the Place bet.

      :param player: The player to check and see if they have the given bet.



   .. py:method:: __repr__() -> str


.. py:class:: AddIfNewShooter(bet: crapssim.bet.Bet)

   Bases: :py:obj:`AddIfTrue`


   Strategy that adds a bet if there is a new shooter at the table, and the Player doesn't have a bet on the
   table. Equivalent to AddIfTrue(bet, lambda p: p.table.new_shooter and bet not in p.bets)


   .. py:method:: __repr__() -> str


.. py:class:: AddIfNotBet(bet: crapssim.bet.Bet)

   Bases: :py:obj:`AddIfTrue`


   Strategy that adds a bet if it isn't on the table for that player. Equivalent of
   AddIfTrue(bet, lambda p: bet not in p.bets)


   .. py:method:: __repr__() -> str


.. py:class:: AddIfPointOff(bet: crapssim.bet.Bet)

   Bases: :py:obj:`AddIfTrue`


   Strategy that adds a bet if the table point is Off, and the Player doesn't have a bet on the
   table. Equivalent to AddIfTrue(bet, lambda p: p.table.point.status == "Off"
                                       and bet not in p.bets)


   .. py:method:: __repr__() -> str


.. py:class:: AddIfPointOn(bet: crapssim.bet.Bet)

   Bases: :py:obj:`AddIfTrue`


   Strategy that adds a bet if the table point is On, and the Player doesn't have a bet on the
   table. Equivalent to AddIfTrue(bet, lambda p: p.table.point.status == "On"
                                       and bet not in p.bets)


   .. py:method:: __repr__() -> str


.. py:class:: AddIfTrue(bet: crapssim.bet.Bet, key: Callable[[Player], bool])

   Bases: :py:obj:`Strategy`


   Strategy that places a bet if a given key taking Player as a parameter is True.


   .. py:attribute:: bet


   .. py:attribute:: key


   .. py:method:: update_bets(player: Player) -> None

      If the key is True add the bet to the player and table.

      :param player: The Player to add the bet for.



   .. py:method:: completed(player: Player) -> bool

      The strategy is completed when the player  can't make a bet because their bankroll is too
       low and the player doesn't have any bets left on the table.

      :param player: The player to check whether the

      :rtype: True if the Player can't continue the strategy, otherwise False.



   .. py:method:: __repr__() -> str


   .. py:method:: __eq__(other: object) -> bool


.. py:class:: AggregateStrategy(*strategies: Strategy)

   Bases: :py:obj:`Strategy`


   A combination of multiple strategies.


   .. py:attribute:: strategies
      :value: ()



   .. py:method:: update_bets(player: Player) -> None

      Go through each of the strategies and run its update_bets method if the strategy has
      not been completed.

      :param player: The player to update the bets for.



   .. py:method:: completed(player: Player) -> bool

      Returns True if all the strategies in the AggregateStrategy are completed.

      :param player: The Player to check the strategy for.

      :rtype: A boolean representing whether the given strategy



   .. py:method:: __repr__() -> str


.. py:class:: CountStrategy(bet_type: type[crapssim.bet.Bet] | tuple[type[crapssim.bet.Bet], Ellipsis], count: int, bet: crapssim.bet.Bet)

   Bases: :py:obj:`AddIfTrue`


   Strategy that checks how many bets exist of a certain type. If the number of bets of that
   type is less than the given count, it places the bet (if the bet isn't already on the table.)


   .. py:attribute:: bet_type


   .. py:attribute:: count


   .. py:method:: key(player: Player) -> bool

      Return True when the player is below the threshold for ``bet_type``.



   .. py:method:: __repr__() -> str


.. py:class:: RemoveIfPointOff(bet: crapssim.bet.Bet)

   Bases: :py:obj:`RemoveIfTrue`


   Strategy that removes a bet if the table point is Off

   This will match bets based on type, and number for Place and Hardway bets.
   It will not consider bet amounts when matching.


   .. py:attribute:: bet


   .. py:method:: __repr__() -> str


.. py:class:: RemoveIfTrue(key: Callable[[crapssim.bet.Bet, Player], bool])

   Bases: :py:obj:`Strategy`


   Strategy that removes all bets that are True for a given key. The key takes the Bet and the
   Player as parameters.


   .. py:attribute:: key


   .. py:method:: update_bets(player: Player) -> None

      For each of the players bets if the key is True remove the bet from the table.

      :param player: The Player to remove the bets for.



   .. py:method:: completed(player: Player) -> bool

      The strategy is completed when the player doesn't have any bets left on the table.

      :param player: The player to check whether the

      :rtype: True if the Player can't continue the strategy, otherwise False.



   .. py:method:: __repr__() -> str


.. py:class:: Strategy

   Bases: :py:obj:`abc.ABC`


   A Strategy is assigned to a player and determines what bets the player
   is going to make, remove, or change.


   .. py:method:: after_roll(player: Player) -> None

      Update the Strategy after the dice are rolled but before the bets and the table are updated.

      For example, if you wanted to know whether the
      point changed from on to off you could do `self.point_lost = table.point.status = "On" and
      table.dice.roll.total == 7`. You could not do this in :func:`Strategy`'s :func:`update_bets`
      method, since the table has already been updated setting the point's status to Off. Other examples
      include counting the number of place bets that had won after the roll, counting total winnings
      for certain bets, or recording the starting bankroll upon a new shooter (to later have logic
      based on winnings of that shooter).

      :param player: The Player to check for bets, etc.



   .. py:method:: completed(player: Player) -> bool
      :abstractmethod:


      If True, the Strategy is completed and the Player stops playing. If False, the Player
      keeps playing the Strategy.



   .. py:method:: update_bets(player: Player) -> None
      :abstractmethod:


      Add, remove, or change the bets on the table.

      This method is applied after the dice are rolled, the bets are updated,
      and the table is updated. It triggers in :py:meth:`.table.TableUpdate.run_strategies`.



   .. py:method:: __add__(other: Strategy) -> AggregateStrategy


   .. py:method:: __eq__(other: object) -> bool


   .. py:method:: __repr__() -> str


